<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Flink 学习笔记之四 时间和窗口"/>




  <meta name="keywords" content="数据处理, 读书笔记, Flink, Lingering Fragments" />










  <link rel="alternate" href="/default" title="Lingering Fragments">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.1" />



<link rel="canonical" href="https://pengye91.github.io/2019/02/21/flink-learning-4/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1" />



  


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-127442719-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-127442719-1');
</script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>








<script>
  window.config = {"title":"Lingering Fragments","subtitle":"一些想法和总结","description":null,"author":"xyp","language":"zh-CN","timezone":"Asia/Shanghai","url":"https://pengye91.github.io","root":"/","permalink":":year/:month/:day/:title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repo":"https://github.com/pengye91/pengye91.github.io.git","branch":"master"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"sitemap":{"path":"sitemap.xml"},"baidusitemap":{"path":"baidusitemap.xml"},"archive_generator":{"per_page":10,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":10},"tag_generator":{"per_page":10},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"compress":false,"header":true},"since":2018,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/","Archives":"/archives/","Tags":"/tags","Categories":"/categories","About":"/about"},"color":"cobalt blue","mode":"default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":false,"license":"<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>"},"reward":{"enable":false,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"pengye91@gmail.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/pengye91","weibo":null,"zhihu":null,"douban":null,"pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":null,"app_key":null},"baidu_analytics":null,"baidu_verification":null,"google_analytics":"UA-127442719-1","google_verification":null,"disqus_shortname":null,"valine":{"appid":"xeDhasO1xV7F1SpCG0oRuiol-gzGzoHsz","appkey":"wgFvo2YMOmn0Qcv7YPFxtePy","notify":false,"verify":false,"avatar":"identicon","visitor":true,"placeholder":"在此评论......"},"changyan":{"appid":null,"appkey":null},"livere_datauid":null,"version":"2.10.1"};
</script>

    <title> Flink 学习笔记之四 时间和窗口 - Lingering Fragments </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Lingering Fragments</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Lingering Fragments</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Flink 学习笔记之四 时间和窗口
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-02-21
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Flink/">Flink</a>
            
              <a href="/categories/Flink/读书笔记/">读书笔记</a>
            
              <a href="/categories/Flink/读书笔记/数据处理/">数据处理</a>
            
          </span>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#设置处理时间"><span class="toc-text">设置处理时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Event-Time-应用中的时间戳和水位"><span class="toc-text">Event-Time 应用中的时间戳和水位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AssignerWithPeriodicWatermarks"><span class="toc-text">AssignerWithPeriodicWatermarks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AssignerWithPunctuatedWatermarks"><span class="toc-text">AssignerWithPunctuatedWatermarks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#水位，延时，准确性"><span class="toc-text">水位，延时，准确性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Process-Function"><span class="toc-text">Process Function</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TimerService-和-Timers"><span class="toc-text">TimerService 和 Timers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#触发到边输出"><span class="toc-text">触发到边输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CoProcessFunction"><span class="toc-text">CoProcessFunction</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#窗口算子"><span class="toc-text">窗口算子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义窗口算子"><span class="toc-text">定义窗口算子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内置的-Window-Assigners"><span class="toc-text">内置的 Window Assigners</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tumbling-Windows"><span class="toc-text">Tumbling Windows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sliding-Windows"><span class="toc-text">Sliding Windows</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Session-Windows"><span class="toc-text">Session Windows</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#将函数作用在窗口上"><span class="toc-text">将函数作用在窗口上</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReduceFunction"><span class="toc-text">ReduceFunction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AggregateFunction"><span class="toc-text">AggregateFunction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProcessWindowFunction"><span class="toc-text">ProcessWindowFunction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#增量聚合-和-ProcessWindowFunction"><span class="toc-text">增量聚合 和 ProcessWindowFunction</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义窗口算子"><span class="toc-text">自定义窗口算子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#窗口的生命周期"><span class="toc-text">窗口的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#窗口分配器"><span class="toc-text">窗口分配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Triggers"><span class="toc-text">Triggers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Evictors"><span class="toc-text">Evictors</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#根据时间-Join-数据流"><span class="toc-text">根据时间 Join 数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Interval-Join"><span class="toc-text">Interval Join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-Join"><span class="toc-text">Window Join</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#处理迟到的数据"><span class="toc-text">处理迟到的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#丢弃迟到的数据"><span class="toc-text">丢弃迟到的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重定向迟到的数据"><span class="toc-text">重定向迟到的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包含迟到的数据更新结果"><span class="toc-text">包含迟到的数据更新结果</span></a></li></ol></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <h1 id="设置处理时间"><a href="#设置处理时间" class="headerlink" title="设置处理时间"></a>设置处理时间</h1><p>在流处理系统中，<strong>时间</strong>是一个非常重要的概念。Flink 可以设置下面三种事件时间。</p>
<ul>
<li><code>ProcessingTime</code><br>  <code>ProcessingTime</code> 意味着算子使用<strong>数据被处理时所在机器的系统时间</strong>。<ul>
<li>优点：延时低，因为算子不用等待按顺序来的数据</li>
<li>缺点：结果不是非确定的。因为每个窗口的数据内容取决于数据到达的速度。</li>
</ul>
</li>
<li><code>EventTime</code><br>  <code>EventTime</code> 指的是算子使用<strong>数据本身包含的时间信息</strong>作为当前时间。每个数据都携带一个时间戳和水位线。当一个水位通知说在给定的时间范围内所有数据已经到达时，<code>event-time</code> 窗口就会触发计算。<br>  <code>EventTime</code> 窗口计算出的结果是确定的：<strong>结果和数据到达的顺序无关</strong>。</li>
<li><code>IngestionTime</code><br>  <code>IngestionTime</code> 是数据进入流处理器的时间。可以将 <code>IngestionTime</code> 理解为 <code>source operator</code> 的 <code>ProcessingTime</code> </li>
</ul>
<a id="more"></a>
<p>设置时间属性如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AverageSensorReadings</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// main() defines and executes the DataStream program</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up the streaming execution environment</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use event time for the application</span></span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ingest sensor stream</span></span><br><span class="line">  <span class="keyword">val</span> sensorData: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env.addSource(...)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Event-Time-应用中的时间戳和水位"><a href="#Event-Time-应用中的时间戳和水位" class="headerlink" title="Event-Time 应用中的时间戳和水位"></a>Event-Time 应用中的时间戳和水位</h2><p>在基于 <code>Event-Time</code> 的流处理应用中，每个数据有两个必需的信息:</p>
<ul>
<li>时间戳<br>  事件发生的时间</li>
<li>水位<br>  算子通过水位推断当前的事件时间。<br>  水位用于通知算子没有比水位更小的时间戳的事件会发生了。</li>
</ul>
<p>可以通过覆盖 <code>SourceFunction</code> 或者 UDF 来生成并分配时间戳和水位。</p>
<p><code>DataStream API</code> 提同乐一个 <code>TimestampAssigner</code> 接口来从数据中提取时间戳。</p>
<p>一种最佳实践是：<em>将分配时间戳和生成水位的操作离数据源越近越好，甚至就在 SourceFunction 内部更好</em>。</p>
<p><code>TimestampAssigner</code> 和其他 <code>transformation</code> 算子类似: 作用在一条数据流中的所有数据，并生成一条新的带有时间戳的数据和水位的数据流。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the event time characteristic</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ingest sensor stream</span></span><br><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env</span><br><span class="line">  .addSource(<span class="keyword">new</span> <span class="type">SensorSource</span>)</span><br><span class="line">  <span class="comment">// assign timestamps and generate watermarks</span></span><br><span class="line">  .assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">MyAssigner</span>())</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>MyAssigner</code> 可以继承自 <code>AssignerWithPeriodicWatermarks</code> 或者 <code>AssingerWithPuctuatedWatermarks</code>。区别如下：</p>
<h2 id="AssignerWithPeriodicWatermarks"><a href="#AssignerWithPeriodicWatermarks" class="headerlink" title="AssignerWithPeriodicWatermarks"></a><code>AssignerWithPeriodicWatermarks</code></h2><p>系统会以一个固定的时间值定期检查 event time 的进展。默认的时间是 200 ms。可以通过 <code>env.getConfig.setAutoWatermarkInterval(interval)</code> 来设置。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"><span class="comment">// generate watermarks every 5 seconds</span></span><br><span class="line">env.getConfig.setAutoWatermarkInterval(<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，系统会每隔 5 秒钟检查当前的水位:</p>
<ol>
<li>Flink 先调用 <code>getCurrentWatermark()</code> 方法；</li>
<li>如果上述方法返回一个时间戳更大的水位，则将新的水位发送。该步骤可以保证时间事件是持续增长的；</li>
<li>反之则不发送。</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeriodicAssigner</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AssignerWithPeriodicWatermarks</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> bound: <span class="type">Long</span> = <span class="number">60</span> * <span class="number">1000</span>     <span class="comment">// 1 min in ms</span></span><br><span class="line">  <span class="keyword">var</span> maxTs: <span class="type">Long</span> = <span class="type">Long</span>.<span class="type">MinValue</span> <span class="comment">// the maximum observed timestamp</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line">    <span class="comment">// generated watermark with 1 min tolerance</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">Watermark</span>(maxTs - bound)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(</span><br><span class="line">      r: <span class="type">SensorReading</span>, </span><br><span class="line">      previousTS: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="comment">// update maximum timestamp</span></span><br><span class="line">    maxTs = maxTs.max(r.timestamp)</span><br><span class="line">    <span class="comment">// return record timestamp</span></span><br><span class="line">    r.timestamp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当事件的发生时间是单调递增的时候，可以在 <code>DataStream</code> 上调用 <code>assignAscendingTimestamps</code> 方法，该方法使用当前的时间戳生成水位: 因为不会出现更早的时间戳。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[<span class="type">MyEvent</span>] = ...</span><br><span class="line"><span class="keyword">val</span> withTimestampsAndWatermarks = stream</span><br><span class="line">      .assignAscendingTimestamps(e =&gt; e.getCreationTime)</span><br></pre></td></tr></table></figure></p>
<h2 id="AssignerWithPunctuatedWatermarks"><a href="#AssignerWithPunctuatedWatermarks" class="headerlink" title="AssignerWithPunctuatedWatermarks"></a><code>AssignerWithPunctuatedWatermarks</code></h2><p>当水位可以基于数据的某些属性来决定时，Flink 提供了 <code>AssignerWithPunctuatedWatermarks</code> 接口，该接口包含 <code>checkAndGetNextWatermark</code> 方法，这个方法会在每次 <code>extractTimestamp()</code> 方法被调用后调用，它可以决定是否生成一个新的水位。另外，和上面一样，如果该方法返回了一个时间戳更大的水位时，发送一个新的水位。</p>
<h2 id="水位，延时，准确性"><a href="#水位，延时，准确性" class="headerlink" title="水位，延时，准确性"></a>水位，延时，准确性</h2><p><strong>水位</strong>是一种可以权衡一个流处理应用<strong>延时</strong>和<strong>结果准确性</strong>的机制：</p>
<ul>
<li><p><strong>松水位</strong><br>  如果水位时间戳远远小于最新事件时间戳，应用的<em>延时</em>会变得比较大，但是<em>准确性</em>会提升。</p>
</li>
<li><p><strong>紧水位</strong><br>  如果水位时间戳和最新事件时间很接近，应用的<em>延时</em>会比较小，但是<em>准确性</em>会下降。</p>
</li>
</ul>
<p><strong>延时-准确性</strong>的权衡是所有流处理系统的一个基本特性。</p>
<h1 id="Process-Function"><a href="#Process-Function" class="headerlink" title="Process Function"></a>Process Function</h1><p><code>DataStream API</code> 提供了一系列的底层可操控<strong>时间戳</strong>和<strong>水位</strong>的<code>ProcessFunction</code>接口。这些接口还可以向系统注册 <code>timer</code> 用于在将来某些特定时间触发事件。另外，<code>process functions</code> 还可以用于将输出数据发送到多个输出。</p>
<p><code>ProcessFunction</code> 接口适用于构建自定义逻辑的事件驱动的应用。对于预定义好的时间窗口的操作可能不太适用。</p>
<p><code>ProcessFunction</code> 可以作用于 <code>DataStream</code> 和 <code>KeyedStream</code> 上，这个方法在 <code>Stream</code> 里的每个数据上调用。</p>
<p><code>ProcessFunction</code> 提供了两个通用的方法:</p>
<ul>
<li><p><code>processElement(v:IN, ctx: Context, out:Collector[OUT])</code><br>  作用在数据流上的每个数据；<br>  输出数据被发送到 <code>Collector</code>;<br>  <code>Context</code> 提供了操控<strong>当前数据时间戳</strong>和<strong>TimeService</strong>的功能；<code>Context</code> 还可以向多个输出流发送数据。</p>
</li>
<li><p><code>onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT])</code><br>  该方法会在指定的已注册的 <code>timer</code> 触发时被调用；<br>  <code>timestamp</code> 参数是指定 timer 触发时的时间戳；<br>  <code>Collector</code> 用于发送结果数据；<br>  <code>OnTimerContext</code> 提供类似 <code>processElement</code> 中 ctx 相同的功能。</p>
</li>
</ul>
<h2 id="TimerService-和-Timers"><a href="#TimerService-和-Timers" class="headerlink" title="TimerService 和 Timers"></a>TimerService 和 Timers</h2><p><code>Context</code> 和 <code>OnTimerContext</code> 中的 <code>TimerService</code> 提供了下述方法：</p>
<ul>
<li><code>currentProcessingTime(): Long</code></li>
<li><code>currentWatermark(): Long</code></li>
<li><code>registerProcessingTimeTimer(timestamp: Long): Unit</code><br>  注册一个作用于当前 key 的  <code>processing time timer</code>。<br>  这个 <code>timer</code> 会在机器的执行时间和 <code>timestamp</code> 参数匹配时触发执行上述 <code>onTimer()</code> 方法；</li>
<li><code></code>registerEventTimeTimer(timestamp: Long): Unit<code>功能一样，只是换做了</code>Event Time`</li>
<li><code>deleteProcessingTimeTimer(timestamp: Long): Unit</code><br>  删除一个 processing timer，如果没有已注册的，则无效。</li>
<li><code>deleteEventTimeTimer(timestamp: Long): Unit</code></li>
</ul>
<p>当 <code>timer</code> 触发时，<code>onTimer()</code> 会被调用，而且 <code>onTimer()</code> 和 <code>processElement</code> 是被同步(synchronized) 调用的。</p>
<blockquote>
<p>timers 只能被用于 keyedStream。</p>
</blockquote>
<p><code>timers</code> 的常用场景是：</p>
<ul>
<li>在经过某段时间的不活跃后清除一个 key 对应的状态；</li>
<li>或者实现自定义的基于时间的窗口逻辑。</li>
</ul>
<blockquote>
<p>可以在每个数据上创建一个不重要的 key 来将一个普通 Stream 变成 KeyedStream。</p>
</blockquote>
<h2 id="触发到边输出"><a href="#触发到边输出" class="headerlink" title="触发到边输出"></a>触发到边输出</h2><p><em>边输出(Side outputs)</em> 是一种可以通过函数将一个输入流的数据处理后触发到多个输出流的机制:</p>
<ul>
<li>除了主输出流外的<strong>边输出流的数量没有限制</strong>；</li>
<li>每个单独的边输出都用 <code>OutputTag[X]</code> 标记；</li>
<li>一个 <code>ProcessFunction</code> 可以<strong>通过 <code>Context</code></strong>将一个数据记录触发到一个或多个边输出。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> monitoredReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = readings</span><br><span class="line">  <span class="comment">// monitor stream for readings with freezing temperatures</span></span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">FreezingMonitor</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve and print the freezing alarms</span></span><br><span class="line">monitoredReadings</span><br><span class="line">  .getSideOutput(<span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">"freezing-alarms"</span>))</span><br><span class="line">  .print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// print the main output</span></span><br><span class="line">readings.print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// =================== //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Emits freezing alarms to a side output for readings </span></span><br><span class="line"><span class="comment">  * with a temperature below 32F. */</span></span><br><span class="line">  </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">FreezingMonitor</span> <span class="keyword">extends</span> <span class="title">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// define a side output tag</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> freezingAlarmOutput: <span class="type">OutputTag</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">"freezing-alarms"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(</span><br><span class="line">      r: <span class="type">SensorReading</span>,</span><br><span class="line">      ctx: <span class="type">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// emit freezing alarm if temperature is below 32F.</span></span><br><span class="line">    <span class="keyword">if</span> (r.temperature &lt; <span class="number">32.0</span>) &#123;</span><br><span class="line">      ctx.output(freezingAlarmOutput, <span class="string">s"Freezing Alarm for <span class="subst">$&#123;r.id&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// forward all readings to the regular output</span></span><br><span class="line">    out.collect(r)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="CoProcessFunction"><a href="#CoProcessFunction" class="headerlink" title="CoProcessFunction"></a><code>CoProcessFunction</code></h2><p>对于两个输入流的操作，<code>DataStream</code> API 提供了 <code>CoProcessFunction</code>。</p>
<p>对于每个输入流，<code>CoProcessFunction</code> 都提供了一个转换函数:</p>
<ul>
<li><code>processElement1()</code></li>
<li><code>processElement2()</code></li>
</ul>
<p>同样的，<code>CoProcessFunction</code> 还提供了 <code>TimerService</code> 等相关接口。</p>
<h1 id="窗口算子"><a href="#窗口算子" class="headerlink" title="窗口算子"></a>窗口算子</h1><p>在流处理系统中，<code>窗口</code>是很常见的概念。<code>窗口算子</code>可以在无限流数据中划分出一个<em>有限范围</em>，然后做各种处理。通常情况下，这个<em>有限范围</em>都是基于时间的。</p>
<h2 id="定义窗口算子"><a href="#定义窗口算子" class="headerlink" title="定义窗口算子"></a>定义窗口算子</h2><p>窗口算子可以作用在</p>
<ul>
<li><code>KeyedStream</code> 上<br>  并行计算</li>
<li><code>non-keyed Stream</code>上<br>  单线程上计算</li>
</ul>
<p>要创建一个窗口算子，需要两个组件：</p>
<ol>
<li><em>Window Assigner</em><br> 决定了数据流中的数据是如何被划分到窗口中的，并且返回一个(keyed) <code>WindowedStream</code> 或者 (non-keyed) <code>AllWindowedStream</code>。</li>
<li><em>Window Function</em><br> 作用于 <code>WindowedStream</code> 或者 <code>AllWindowedStream</code>上，然后处理窗口中的元素。</li>
</ol>
<p>如下面代码所示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a keyed window operator</span></span><br><span class="line">stream</span><br><span class="line">  .keyBy(...)                 </span><br><span class="line">  .window(...)                   <span class="comment">// specify the window assigner</span></span><br><span class="line">  .reduce/aggregate/process(...) <span class="comment">// specify the window function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define a non-keyed window-all operator</span></span><br><span class="line">stream</span><br><span class="line">  .windowAll(...)                <span class="comment">// specify the window assigner</span></span><br><span class="line">  .reduce/aggregate/process(...) <span class="comment">// specify the window function</span></span><br></pre></td></tr></table></figure>
<h2 id="内置的-Window-Assigners"><a href="#内置的-Window-Assigners" class="headerlink" title="内置的 Window Assigners"></a>内置的 Window Assigners</h2><p>基于时间的窗口会根据事件时间(event time 或者 processing time)将一个数据分配给某个<strong>窗口</strong>。每个时间窗口都有一个<strong>开始时间戳</strong>和<strong>结束时间戳</strong>。</p>
<p>所有内置的窗口分配器都会提供一个默认的<strong>触发器</strong>，一旦时间超过某个窗口的结束时间，触发器就会触发对这个窗口的计算。</p>
<h2 id="Tumbling-Windows"><a href="#Tumbling-Windows" class="headerlink" title="Tumbling Windows"></a>Tumbling Windows</h2><p><code>TumblingWindow</code> 会将数据放在不重叠，大小固定的窗口中：</p>
<center><img src="/images/flink/1550678493713.png" alt="Alt text"></center>

<p>内置了两个分配器：<code>TumblingEventTimeWindows</code> 和 <code>TumblingProcessingTimeWindows</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sensorData: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> avgTemp = sensorData</span><br><span class="line">.keyBy(_.id)</span><br><span class="line"><span class="comment">// group readings in 1s event-time windows</span></span><br><span class="line">.window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">1</span>)))</span><br><span class="line">.process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br></pre></td></tr></table></figure>
<p>一种简写方式是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> avgTemp = sensorData</span><br><span class="line">.keyBy(_.id)</span><br><span class="line"><span class="comment">// shortcut for window.(TumblingEventTimeWindows.of(size))</span></span><br><span class="line"><span class="comment">// timeWindow 方法会根据 timeCharacter 来决定是 EventTimeWindows 还是 ProcessingTimeWindows</span></span><br><span class="line">.timeWindow(<span class="type">Time</span>.seconds(<span class="number">1</span>))</span><br><span class="line">.process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br></pre></td></tr></table></figure>
<p>默认情况下，tumbling windows 和纪元时间(<code>1970-01-01-00:00:00.000</code>)对齐，比如，一个大小为一小时的窗口的开始和结束时间为: 00:00:00, 01:0:00, 02:00:00 等。</p>
<p>所以，分配器还提供了第二个参数，可以控制<strong>偏移量</strong>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> avgTemp = sensorData</span><br><span class="line">.keyBy(_.id)</span><br><span class="line"><span class="comment">// group readings in 1 hour windows with 15 min offset</span></span><br><span class="line"><span class="comment">// 00:15:00, 01:15:00, 02:15:00 ...</span></span><br><span class="line">.window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.hours(<span class="number">1</span>), <span class="type">Time</span>.minutes(<span class="number">15</span>)))</span><br><span class="line">.process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span></span><br></pre></td></tr></table></figure>
<h2 id="Sliding-Windows"><a href="#Sliding-Windows" class="headerlink" title="Sliding Windows"></a>Sliding Windows</h2><p>SlidingWindow 会将数据分配到长度固定，<strong>但可能会重叠</strong>的窗口中：</p>
<center><img src="/images/flink/1550680297501.png" alt="Alt text"></center>

<p>对于一个滑动窗口，需要声明两个参数: <em>窗口大小</em>和<em>新窗口生成频率</em>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-time sliding windows assigner</span></span><br><span class="line"><span class="keyword">val</span> slidingAvgTemp = sensorData</span><br><span class="line">.keyBy(_.id)</span><br><span class="line"><span class="comment">// create 1h event-time windows every 15 minutes</span></span><br><span class="line">.window(<span class="type">SlidingEventTimeWindows</span>.of(<span class="type">Time</span>.hours(<span class="number">1</span>), <span class="type">Time</span>.minutes(<span class="number">15</span>)))</span><br><span class="line">.process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br></pre></td></tr></table></figure></p>
<p>有两种情况：</p>
<ul>
<li>当窗口生成频率<strong>小于</strong>窗口大小时，窗口会重叠，数据可能会被分配给两个窗口；</li>
<li>当窗口生成频率<strong>大于</strong>窗口大小时，有些数据可能会得不到分配。</li>
</ul>
<p>也可以传入第三个参数：<em>偏移量</em></p>
<p>同样的，也可以用快捷方法：<code>timeWindow(windowSize, slideSize)</code> 来表示滑动窗口。</p>
<h2 id="Session-Windows"><a href="#Session-Windows" class="headerlink" title="Session Windows"></a>Session Windows</h2><p>Session Window 将数据分配到 <strong>不覆盖</strong>，<strong>长度不固定</strong>的窗口中。</p>
<p>Session Window 的边界由<em>不活跃间隔</em>定义：例如，<strong>没收到任何数据的时间长度</strong>。</p>
<center><img src="/images/flink/1550758161157.png" alt="Alt text"></center>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-time session windows assigner</span></span><br><span class="line"><span class="keyword">val</span> sessionWindows = sensorData</span><br><span class="line">.keyBy(_.id)</span><br><span class="line"><span class="comment">// create event-time session windows with a 15 min gap</span></span><br><span class="line">.window(<span class="type">EventTimeSessionWindows</span>.withGap(<span class="type">Time</span>.minutes(<span class="number">15</span>)))</span><br><span class="line">.process(...)</span><br></pre></td></tr></table></figure>
<p><code>SessionWindows</code> 会先将每个输入数据分配到单独的窗口，以数据的时间为窗口开始时间，并且以 session gap 为窗口大小，最后会将所有窗口合并。</p>
<h1 id="将函数作用在窗口上"><a href="#将函数作用在窗口上" class="headerlink" title="将函数作用在窗口上"></a>将函数作用在窗口上</h1><p>窗口上的函数有两种：</p>
<ul>
<li><p><em>增量聚合函数</em><br>  每当有输入数据加入窗口时，函数就作用在其上，并更新一个单独的窗口状态值。<br>  空间效率非常高，最终会出发一个聚合后的结果。<br>  <code>ReduceFunction</code> 和 <code>AggregateFunction</code> 是常见的增量聚合函数。</p>
</li>
<li><p><em>全窗口函数</em><br>  会先收集窗口中的所有数据，然后遍历计算。<br>  需要更多空间。但是适用于更复杂的逻辑。<br>  <code>ProcessWindowFunction</code> 是全窗口函数。</p>
</li>
</ul>
<h2 id="ReduceFunction"><a href="#ReduceFunction" class="headerlink" title="ReduceFunction"></a>ReduceFunction</h2><p><code>ReduceFunction</code> 接收两个类型相同的数据，并将其结合输出为一个类型相同的值：单个窗口状态。</p>
<p>当有新数据加入窗口时：该函数被调用，并传入新数据和窗口状态值作为参数。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>窗口状态恒定而且数据量小；</li>
<li>接口简单；</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>输入和输出结果类型都是相同的。因此通常被限制为简单的聚合方法。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minTempPerWindow: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = sensorData</span><br><span class="line">    .map(r =&gt; (r.id, r.temperature))</span><br><span class="line">    .keyBy(_._1)</span><br><span class="line">    .timeWindow(<span class="type">Time</span>.seconds(<span class="number">15</span>))</span><br><span class="line">    .reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</span><br></pre></td></tr></table></figure>
<h2 id="AggregateFunction"><a href="#AggregateFunction" class="headerlink" title="AggregateFunction"></a>AggregateFunction</h2><p>增量聚合，窗口状态单一，但是接口更灵活也更复杂:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="type">AggregateFunction</span>&lt;<span class="type">IN</span>, <span class="type">ACC</span>, <span class="type">OUT</span>&gt; <span class="keyword">extends</span> <span class="type">Function</span>, <span class="type">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// create a new accumulator to start a new aggregate.</span></span><br><span class="line"> <span class="type">ACC</span> createAccumulator();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// add an input element to the accumulator and return the accumulator.</span></span><br><span class="line"> <span class="type">ACC</span> add(<span class="type">IN</span> value, <span class="type">ACC</span> accumulator);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// merge two accumulators and return the result.</span></span><br><span class="line"> <span class="type">ACC</span> merge(<span class="type">ACC</span> a, <span class="type">ACC</span> b);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// compute the result from the accumulator and return it.</span></span><br><span class="line"> <span class="type">OUT</span> getResult(<span class="type">ACC</span> accumulator);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，输出，输入，中间状态都可以是<strong>不同类型</strong>。</p>
<h2 id="ProcessWindowFunction"><a href="#ProcessWindowFunction" class="headerlink" title="ProcessWindowFunction"></a>ProcessWindowFunction</h2><p>有些场景是<em>增量聚合函数</em>很难实现的，比如：取中位数，词频等。</p>
<p><code>ProcessWindowFunction</code> 可以先收集窗口中所有数据，然后在作用其上计算：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunction&lt;IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window&gt;</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Evaluates the window.</span></span><br><span class="line">  void process(<span class="type">KEY</span> key, <span class="type">Context</span> ctx, <span class="type">Iterable</span>&lt;<span class="type">IN</span>&gt; vals, <span class="type">Collector</span>&lt;<span class="type">OUT</span>&gt; out) <span class="keyword">throws</span> <span class="type">Exception</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Deletes any custom per-window state when the window is purged.</span></span><br><span class="line">  public void clear(<span class="type">Context</span> ctx) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The context holding window metadata.</span></span><br><span class="line">  public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Returns the metadata of the window</span></span><br><span class="line">    public <span class="keyword">abstract</span> <span class="type">W</span> window();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the current processing time.</span></span><br><span class="line">    public <span class="keyword">abstract</span> long currentProcessingTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the current event-time watermark.</span></span><br><span class="line">    public <span class="keyword">abstract</span> long currentWatermark();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// State accessor for per-window state.</span></span><br><span class="line">    public <span class="keyword">abstract</span> <span class="type">KeyedStateStore</span> windowState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// State accessor for per-key global state.</span></span><br><span class="line">    public <span class="keyword">abstract</span> <span class="type">KeyedStateStore</span> globalState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emits a record to the side output identified by the OutputTag.</span></span><br><span class="line">    public <span class="keyword">abstract</span> &lt;<span class="type">X</span>&gt; void output(<span class="type">OutputTag</span>&lt;<span class="type">X</span>&gt; outputTag, <span class="type">X</span> value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，和其他 <code>ProcessFunction</code> 一样，该方法也提供 <code>Context</code> 参数，这个参数除了普通的方法外，还提供窗口的一些原信息，比如：开始时间，结束时间，以及<strong>每个窗口的状态 windowState()</strong>和<strong>每个 key 的总状态 globalState()</strong>。</p>
<p>例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// output the lowest and highest temperature reading every 5 seconds</span></span><br><span class="line"><span class="keyword">val</span> minMaxTempPerWindow: <span class="type">DataStream</span>[<span class="type">MinMaxTemp</span>] = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">HighAndLowTempProcessFunction</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MinMaxTemp</span>(<span class="params">id: <span class="type">String</span>, min: <span class="type">Double</span>, max:<span class="type">Double</span>, endTs: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">/**</span></span></span><br><span class="line"><span class="class"> <span class="title">*</span> <span class="title">A</span> <span class="title">ProcessWindowFunction</span> <span class="title">that</span> <span class="title">computes</span> <span class="title">the</span> <span class="title">lowest</span> <span class="title">and</span> <span class="title">highest</span> <span class="title">temperature</span></span></span><br><span class="line"><span class="class"> <span class="title">*</span> <span class="title">reading</span> <span class="title">per</span> <span class="title">window</span> <span class="title">and</span> <span class="title">emits</span> <span class="title">a</span> <span class="title">them</span> <span class="title">together</span> <span class="keyword">with</span> <span class="title">the</span> </span></span><br><span class="line"><span class="class"> <span class="title">*</span> <span class="title">end</span> <span class="title">timestamp</span> <span class="title">of</span> <span class="title">the</span> <span class="title">window</span>.</span></span><br><span class="line"><span class="class"> <span class="title">*/</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HighAndLowTempProcessFunction</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>[<span class="type">SensorReading</span>, <span class="type">MinMaxTemp</span>, <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(</span><br><span class="line">      key: <span class="type">String</span>,</span><br><span class="line">      ctx: <span class="type">Context</span>,</span><br><span class="line">      vals: <span class="type">Iterable</span>[<span class="type">SensorReading</span>],</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">MinMaxTemp</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> temps = vals.map(_.temperature)</span><br><span class="line">    <span class="keyword">val</span> windowEnd = ctx.window.getEnd</span><br><span class="line"></span><br><span class="line">    out.collect(<span class="type">MinMaxTemp</span>(key, temps.min, temps.max, windowEnd))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增量聚合-和-ProcessWindowFunction"><a href="#增量聚合-和-ProcessWindowFunction" class="headerlink" title="增量聚合 和 ProcessWindowFunction"></a>增量聚合 和 ProcessWindowFunction</h2><p>有这样的场景：窗口函数可以被表达为<em>增量聚合函数</em>，但同时也想获取<em>窗口的元信息</em>。</p>
<p>在这种场景下，可以将两者结合：</p>
<ul>
<li>当数据进入窗口后，立即被增量聚合函数处理；</li>
<li>当触发器触发时，聚合结果被交给 <code>ProcessWindowFunction</code>;</li>
<li><code>ProcessWindowFunction.process</code> 方法的 <code>vals: Iterable</code> 参数只有一个值：上述的聚合结果。 </li>
</ul>
<p>在 DataStream API 中，调用方法为:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input</span><br><span class="line">  .keyBy(...)</span><br><span class="line">  .timeWindow(...)</span><br><span class="line">  <span class="comment">// 或者 .aggregate</span></span><br><span class="line">  .reduce(incrAggregator: <span class="type">ReduceFunction</span>[<span class="type">IN</span>],</span><br><span class="line">    function: <span class="type">ProcessWindowFunction</span>[<span class="type">IN</span>, <span class="type">OUT</span>, <span class="type">K</span>, <span class="type">W</span>])</span><br></pre></td></tr></table></figure>
<p>上面的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minMaxTempPerWindow2: <span class="type">DataStream</span>[<span class="type">MinMaxTemp</span>] = sensorData</span><br><span class="line">  .map(r =&gt; (r.id, r.temperature, r.temperature))</span><br><span class="line">  .keyBy(_._1)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">  .reduce(</span><br><span class="line">    <span class="comment">// incrementally compute min and max temperature</span></span><br><span class="line">    (r1: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>), r2: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)) =&gt; &#123;</span><br><span class="line">      (r1._1, r1._2.min(r2._2), r1._3.max(r2._3))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// finalize result in ProcessWindowFunction</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">AssignWindowEndProcessFunction</span>()</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========= //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MinMaxTemp</span>(<span class="params">id: <span class="type">String</span>, min: <span class="type">Double</span>, max:<span class="type">Double</span>, endTs: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AssignWindowEndProcessFunction</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>), <span class="type">MinMaxTemp</span>, <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(</span><br><span class="line">      key: <span class="type">String</span>,</span><br><span class="line">      ctx: <span class="type">Context</span>,</span><br><span class="line">      minMaxIt: <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)],</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">MinMaxTemp</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> minMax = minMaxIt.head</span><br><span class="line">    <span class="keyword">val</span> windowEnd = ctx.window.getEnd</span><br><span class="line">    out.collect(<span class="type">MinMaxTemp</span>(key, minMax._2, minMax._3, windowEnd))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义窗口算子"><a href="#自定义窗口算子" class="headerlink" title="自定义窗口算子"></a>自定义窗口算子</h1><p>自定义窗口算子可以解决一些内置窗口无法解决的问题：</p>
<ul>
<li>在窗口结束前发送结果；</li>
<li>当有迟到的数据进入窗口后，更新相应的状态；</li>
<li>当遇到特殊的数据条目时，开始或者结束一个窗口。</li>
</ul>
<p>通过定义 <code>assingers</code>, <code>triggers</code>, <code>evictors</code> 和 <code>window functions</code> 可以定义一个窗口算子并处理其中的元素：</p>
<ol>
<li>当有数据到达窗口算子，被 <code>WindowAssigner</code> 处理。这个方法决定了数据被分配到哪个窗口，如果这个窗口不存在，那么就会被新创建；</li>
<li>如果<code>窗口函数</code>是<em>增量聚合函数</em>，那么新数据会被立即聚合，计算结果被<em>存储为窗口的内容</em>；反之，如果是<code>全窗口函数</code>，新元素会被追加到<code>ListState</code>用于保存窗口所有的函数。</li>
<li><p>当数据被分配给一个窗口时，同时也被传给窗口的<code>Trigger</code>。<br> <em>触发器</em>定义了一个窗口何时被认为准备好评估以及何时被关闭清除内容。<br> <em>触发器</em>的定义可以基于窗口中<em>元素的数量</em>和<em>注册的<code>timer</code></em>。<br> 当触发器触发时，其具体行为由注册的窗口函数决定：</p>
<ul>
<li>如果是<em>增量聚合函数</em>，当前的聚合结果立即被触发。<center><img src="/images/flink/1550899320409.png" alt="Alt text"></center></li>
<li>如果是<em>全窗口函数</em>：<center><img src="/images/flink/1550899424963.png" alt="Alt text"></center></li>
<li>如果是<em>混合型</em>:<center><img src="/images/flink/1550899493997.png" alt="Alt text"></center>
</li>
</ul>
</li>
<li><p><code>Evictor</code> 是一个可选项，用于清除一个窗口中所有的元素，由于需要遍历，所有只能作用在<em>全窗口函数</em>上。</p>
</li>
</ol>
<p>下例描述了如何定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">  .keyBy(...)</span><br><span class="line">  .window(...)                   <span class="comment">// specify the window assigner</span></span><br><span class="line">  <span class="comment">// optional: specify the trigger</span></span><br><span class="line">  <span class="comment">// window 分配器中默认都有一个 trigger</span></span><br><span class="line">  <span class="comment">// 如果显式地声明了 trigger，则会覆盖默认的</span></span><br><span class="line"> [.trigger(...)]                 </span><br><span class="line"> [.evictor(...)]                 <span class="comment">// optional: specify the evictor</span></span><br><span class="line">  .reduce/aggregate/process(...) <span class="comment">// specify the window function</span></span><br></pre></td></tr></table></figure>
<h2 id="窗口的生命周期"><a href="#窗口的生命周期" class="headerlink" title="窗口的生命周期"></a>窗口的生命周期</h2><ol>
<li><p>创建</p>
<p> 当 <code>WindowAssigner</code> 分配第一个元素给窗口时，被创建。因此，不存在<em>一个元素都不存在的窗口</em>。一个窗口包含不同的<strong>状态</strong>：</p>
<ul>
<li><strong>窗口内容</strong><br>  <em>窗口内容</em>包含了被分配的所有元素，或者<em>聚合结果</em>(如果是增量聚合函数)。</li>
<li><strong>窗口对象</strong><br>  <em>窗口对象</em>保存了可以分辨不同窗口的信息。每个<em>窗口对象</em>都有一个结束时间戳用于定义窗口可以被删除的时间。</li>
<li><strong>触发器的 timer</strong><br>  一个 <code>Trigger</code> 可以注册定时器用于在特定时间被回调：评估窗口或者清除窗口内容。<br>  由窗口算子维护。</li>
<li><strong>触发器中自定义的状态</strong><br>  可以自定义每个窗口中的状态或者每个key对应的状态。<br>  由<em>触发器</em>维护。</li>
</ul>
</li>
<li><p>删除</p>
<p> 当时间到达窗口的<em>结束时间</em>时，窗口被删除。<br> 当窗口被删除后，窗口算子会清楚这个窗口的窗口内容，并丢弃窗口对象。<br> <strong>触发器状态和定时器不会被清除</strong>，因为它们是由窗口算子维护。<br> 所以，需要调用 <code>Trigger.clear()</code> 来清除状态以防止状态泄露。</p>
</li>
</ol>
<h2 id="窗口分配器"><a href="#窗口分配器" class="headerlink" title="窗口分配器"></a>窗口分配器</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A custom window that groups events into 30 second tumbling windows. */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirtySecondsWindows</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">WindowAssigner</span>[<span class="type">Object</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> windowSize: <span class="type">Long</span> = <span class="number">30</span> * <span class="number">1000</span>L</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">assignWindows</span></span>(</span><br><span class="line">      o: <span class="type">Object</span>,</span><br><span class="line">      ts: <span class="type">Long</span>,</span><br><span class="line">      ctx: <span class="type">WindowAssigner</span>.<span class="type">WindowAssignerContext</span>): java.util.<span class="type">List</span>[<span class="type">TimeWindow</span>] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rounding down by 30 seconds</span></span><br><span class="line">    <span class="keyword">val</span> startTime = ts - (ts % windowSize)</span><br><span class="line">    <span class="keyword">val</span> endTime = startTime + windowSize</span><br><span class="line">    <span class="comment">// emitting the corresponding time window</span></span><br><span class="line">    <span class="type">Collections</span>.singletonList(<span class="keyword">new</span> <span class="type">TimeWindow</span>(startTime, endTime))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getDefaultTrigger</span></span>(</span><br><span class="line">      env: environment.<span class="type">StreamExecutionEnvironment</span>): <span class="type">Trigger</span>[<span class="type">Object</span>, <span class="type">TimeWindow</span>] = &#123;</span><br><span class="line">    <span class="type">EventTimeTrigger</span>.create()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getWindowSerializer</span></span>(</span><br><span class="line">      executionConfig: <span class="type">ExecutionConfig</span>): <span class="type">TypeSerializer</span>[<span class="type">TimeWindow</span>] = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">TimeWindow</span>.<span class="type">Serializer</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isEventTime</span> </span>= <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h2><p><em>触发器</em>可以基于数据特性或者时间特性来决定计算一个窗口。</p>
<p><em>触发器</em>可以接触到窗口的元数据，包括时间，定时器，状态等。</p>
<p><em>触发器</em>可以做到如下述场景：</p>
<ul>
<li>当窗口接收到固定数量的数据；</li>
<li>某个特定的数据到达窗口；</li>
<li>在当前时间未达到水位时触发计算返回结果(可以降低时延)；</li>
</ul>
<p>等等。</p>
<p>没当<em>trigger</em>被调用时，会返回一个 <code>TriggerResult</code>，用于决定窗口的动作。</p>
<ul>
<li><code>CONTINUE</code>: 不做任何操作；</li>
<li><code>FIRE</code>: 如果窗口函数是 <em>增量聚合函数</em>，那么这个函数被调用，结果被触发；窗口状态不变；</li>
<li><code>PURGE</code>: 清除窗口内容和状态；</li>
<li><code>FIRE_AND_PURGE</code>: 先 <code>FIRE</code> 再 <code>PURGE</code>。</li>
</ul>
<h2 id="Evictors"><a href="#Evictors" class="headerlink" title="Evictors"></a>Evictors</h2><p><em>Evictors</em> 可以在窗口函数被计算后或者计算前清除其中的元素。</p>
<p>接口如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="type">Evictor</span>&lt;<span class="type">T</span>, <span class="type">W</span> <span class="keyword">extends</span> <span class="type">Window</span>&gt; <span class="keyword">extends</span> <span class="type">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optionally evicts elements. Called before windowing function.</span></span><br><span class="line">  void evictBefore(</span><br><span class="line">      <span class="type">Iterable</span>&lt;<span class="type">TimestampedValue</span>&lt;<span class="type">T</span>&gt;&gt; elements, </span><br><span class="line">      int size, </span><br><span class="line">      <span class="type">W</span> window, </span><br><span class="line">      <span class="type">EvictorContext</span> evictorContext);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optionally evicts elements. Called after windowing function.</span></span><br><span class="line">  void evictAfter(</span><br><span class="line">     <span class="type">Iterable</span>&lt;<span class="type">TimestampedValue</span>&lt;<span class="type">T</span>&gt;&gt; elements, </span><br><span class="line">     int size, </span><br><span class="line">     <span class="type">W</span> window, </span><br><span class="line">     <span class="type">EvictorContext</span> evictorContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A context object that is given to Evictor methods.</span></span><br><span class="line">interface <span class="type">EvictorContext</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the current processing time.</span></span><br><span class="line">  long getCurrentProcessingTime();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the current event time watermark.</span></span><br><span class="line">  long getCurrentWatermark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="根据时间-Join-数据流"><a href="#根据时间-Join-数据流" class="headerlink" title="根据时间 Join 数据流"></a>根据时间 Join 数据流</h1><p>常见场景：<strong>Join 两个数据流中的数据</strong>。</p>
<p>Flink 内置了两个处理这种场景的算子。</p>
<h2 id="Interval-Join"><a href="#Interval-Join" class="headerlink" title="Interval Join"></a>Interval Join</h2><h2 id="Window-Join"><a href="#Window-Join" class="headerlink" title="Window Join"></a>Window Join</h2><h1 id="处理迟到的数据"><a href="#处理迟到的数据" class="headerlink" title="处理迟到的数据"></a>处理迟到的数据</h1><p>Flink 基于水位来处理 event time 的进程。正如上面讨论的，总会有迟到的事件(事件时间小于水位)在事后才到达。</p>
<p>有以下几种处理方式：</p>
<h2 id="丢弃迟到的数据"><a href="#丢弃迟到的数据" class="headerlink" title="丢弃迟到的数据"></a>丢弃迟到的数据</h2><p>最简单的办法。</p>
<p>也是 EventTime 窗口的默认方法。</p>
<p>ProcessFunction 可以通过对比事件时间和当前水位决定是否丢弃。</p>
<h2 id="重定向迟到的数据"><a href="#重定向迟到的数据" class="headerlink" title="重定向迟到的数据"></a>重定向迟到的数据</h2><p>通过 <code>SideOutput</code> 将迟到的数据重定向到另一个数据流，然后再取出来做业务上的处理：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define a side output tag</span></span><br><span class="line"><span class="keyword">val</span> lateReadingsOutput: <span class="type">OutputTag</span>[<span class="type">SensorReading</span>] =</span><br><span class="line">  <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">SensorReading</span>](<span class="string">"late-readings"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =================== //</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ???</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> filteredReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = readings</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">LateReadingsFilter</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve late readings</span></span><br><span class="line"><span class="keyword">val</span> lateReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = filteredReadings</span><br><span class="line">  .getSideOutput(lateReadingsOutput)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =================== //</span></span><br><span class="line"><span class="comment">/** A ProcessFunction that filters out late sensor readings and </span></span><br><span class="line"><span class="comment">  * re-directs them to a side output */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LateReadingsFilter</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(</span><br><span class="line">      r: <span class="type">SensorReading</span>,</span><br><span class="line">      ctx: <span class="type">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare record timestamp with current watermark</span></span><br><span class="line">    <span class="keyword">if</span> (r.timestamp &lt; ctx.timerService().currentWatermark()) &#123;</span><br><span class="line">      <span class="comment">// this is a late reading =&gt; redirect it to the side output</span></span><br><span class="line">      ctx.output(lateReadingsOutput, r)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      out.collect(r)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包含迟到的数据更新结果"><a href="#包含迟到的数据更新结果" class="headerlink" title="包含迟到的数据更新结果"></a>包含迟到的数据更新结果</h2><p>将迟到的数据包括进来，然后重新计算一次。</p>
<p>问题多多:</p>
<ul>
<li>为了重新计算所有的数据，算子必须保存所有的状态；</li>
<li>下游算子也要重新计算，甚至 Sink 到磁盘的算子也要覆盖；</li>
</ul>
<p>Flink 给窗口算子提供了一个允许的迟到时间: <code>allowedLateness</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ???</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> countPer10Secs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>, <span class="type">String</span>)] = readings</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">10</span>))</span><br><span class="line">  <span class="comment">// process late readings for 5 additional seconds</span></span><br><span class="line">  .allowedLateness(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">  <span class="comment">// count readings and update results if late readings arrive</span></span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">UpdatingWindowCountFunction</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =================== //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** A counting WindowProcessFunction that distinguishes between </span></span><br><span class="line"><span class="comment">  * first results and updates. */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdatingWindowCountFunction</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>[<span class="type">SensorReading</span>, (<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>, <span class="type">String</span>), <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(</span><br><span class="line">      id: <span class="type">String</span>,</span><br><span class="line">      ctx: <span class="type">Context</span>,</span><br><span class="line">      elements: <span class="type">Iterable</span>[<span class="type">SensorReading</span>],</span><br><span class="line">      out: <span class="type">Collector</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>, <span class="type">String</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">:</span><br><span class="line">    <span class="comment">// count the number of readings</span></span><br><span class="line">    <span class="keyword">val</span> cnt = elements.count(_ =&gt; <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state to check if this is the first evaluation of the window or not.</span></span><br><span class="line">    <span class="keyword">val</span> isUpdate = ctx.windowState.getState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Boolean</span>](<span class="string">"isUpdate"</span>, <span class="type">Types</span>.of[<span class="type">Boolean</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isUpdate.value()) &#123;</span><br><span class="line">      <span class="comment">// first evaluation, emit first result</span></span><br><span class="line">      out.collect((id, ctx.window.getEnd, cnt, <span class="string">"first"</span>))</span><br><span class="line">      isUpdate.update(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// not the first evaluation, emit an update</span></span><br><span class="line">      out.collect((id, ctx.window.getEnd, cnt, <span class="string">"update"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/数据处理/">数据处理</a>
            
              <a href="/tags/读书笔记/">读书笔记</a>
            
              <a href="/tags/Flink/">Flink</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/02/27/flink-learning-5/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Flink 学习笔记之五 状态操作符和用户函数</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/02/06/scala-fp-1/">
        <span class="next-text nav-default">Scala 函数式编程 一</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="vcomments"></div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:pengye91@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/pengye91" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2018 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">xyp</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  
<!-- valine Comments -->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//cdn.jsdelivr.net/gh/xcss/valine@v1.3.3/dist/Valine.min.js"></script>
<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: false,
        visitor: true,
        app_id: "xeDhasO1xV7F1SpCG0oRuiol-gzGzoHsz",
        app_key: "wgFvo2YMOmn0Qcv7YPFxtePy",
        placeholder: "在此评论......",
        avatar: 'identicon'
    });
</script>


  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script>

  </body>
</html>
